<directory_structure>
Capstone_AI_refactored/
  core/
    __init__.py
    config_manager.py
    inference_engine.py
    knowledge_base.py
  detection/
    __init__.py
    eigrp_tree.py
    interface_tree.py
    ospf_tree.py
    problem_detector.py
  resolution/
    __init__.py
    fix_applier.py
    fix_recommender.py
  utils/
    __init__.py
    network_utils.py
    reporter.py
    telnet_utils.py
  config_parser.py
  runner.py
</directory_structure>

General Architecture
The project follows a modular expert system architecture with separation between detection (symptom identification), knowledge (rules + learning), inference (reasoning), and resolution (fix application). Configuration management and baseline tracking run throughout as foundational services.

Core System Files
core/config_manager.py

Manages baseline configuration storage and retrieval
Parses router configs into structured data (EIGRP, OSPF, interfaces)
KEY LOGIC: Determines expected values (timers, IPs, router IDs) from baseline
Validates current state against stable configurations
Provides topology-aware helper methods (is_eigrp_router, should_interface_be_up)
Handles config versioning with auto-incrementing filenames

core/knowledge_base.py

Stores and manages troubleshooting rules as data structures
KEY LOGIC: Rule matching engine - finds applicable rules for problems
Implements confidence scoring and learning from fix outcomes
KEY LOGIC: Tiered recommendation system (topology-independent → baseline-validated → low-confidence)
Validates and formats rules with baseline context
Tracks problem history and rule performance statistics
Handles KB export/import for persistence

core/inference_engine.py

Performs symbolic reasoning on detected problems
KEY LOGIC: Diagnoses problems by applying rules and chaining symptoms to root causes
Generates fix recommendations with confidence scores
KEY LOGIC: Conflict detection between competing fixes
Creates optimized fix plans with dependency analysis and phasing
Predicts fix outcomes and side effects
Calculates fix priorities using multi-criteria weighting
Handles uncertainty with diagnostic command suggestions


Detection Module Files
detection/problem_detector.py

Coordinates all detection modules (interfaces, EIGRP, OSPF)
KEY LOGIC: Orchestrates parallel device scanning across network
Aggregates problems by category and device
Prioritizes problems by severity
Correlates related issues (e.g., down interface → routing failures)
Calculates network health scores

detection/interface_tree.py

Detects interface-level issues (shutdown, IP mismatches)
KEY LOGIC: Compares current interface state to baseline expectations
Identifies missing/incorrect IP configurations
Parses "show ip interface brief" output
Applies interface fixes (no shutdown, IP address changes)
Verifies interface status post-fix

detection/eigrp_tree.py

Detects EIGRP-specific problems
KEY LOGIC: Checks AS mismatches, K-value mismatches, stub config, passive interfaces
Monitors EIGRP timers (hello/hold intervals) per interface
Validates network statements against baseline
KEY LOGIC: Parses EIGRP debug output for authentication/subnet issues
Generates EIGRP-specific fix commands
Verifies neighbor adjacencies

detection/ospf_tree.py

Detects OSPF-specific problems
KEY LOGIC: Checks process ID, router ID conflicts, area mismatches
Monitors OSPF timers (hello/dead intervals) per interface
Validates network statements and interface participation
Detects stub area misconfigurations and passive interfaces
KEY LOGIC: Parses OSPF debug for duplicate RID, authentication issues
Generates OSPF-specific fix commands
Verifies neighbor adjacencies


Resolution Module Files
resolution/fix_recommender.py

Generates detailed fix recommendations from diagnoses
KEY LOGIC: Customizes fix templates with problem-specific values
Creates multi-phase fix plans (sequential, parallel, optimal)
Assesses fix risks and prerequisites
KEY LOGIC: Groups independent fixes for parallel execution
Generates rollback plans for all fixes
Validates fixes against current state before application
Estimates impact and downtime

resolution/fix_applier.py

Executes fixes on live devices via telnet
KEY LOGIC: Applies interface, EIGRP, and OSPF fixes with user confirmation
Supports auto-approve mode for batch operations
KEY LOGIC: Implements learning loop - updates KB rule confidence after each fix
Collects verification results post-fix
Tracks all applied fixes in session history


Utility Files
utils/telnet_utils.py

Handles all telnet connection management
Sends commands and collects output
KEY LOGIC: Robust config retrieval with timeout handling
Manages debug enable/disable
Clears buffers and resets connection state

utils/reporter.py

Rich console output formatting (tables, colors, progress bars)
KEY LOGIC: Generates diagnostic summaries and fix completion reports
Saves run history to timestamped files
Creates device health reports
Auto-increments history filenames

utils/network_utils.py

Network calculation helpers (IP/subnet math, wildcard conversions)
Parses interface names, IP addresses, router IDs
KEY LOGIC: IP-in-network matching for OSPF area validation
Validates subnet masks and formats MAC addresses
Extracts bandwidth and other metrics from command output


Main Execution Files
runner.py

Main application orchestrator
KEY LOGIC: Connects to GNS3 API to discover running devices
Manages telnet connections to all devices
Executes diagnostic workflow (scan → fix → save/restore configs)
KEY LOGIC: Parallel configuration restoration with ThreadPoolExecutor
Provides interactive CLI menu system
Integrates all modules (detector, inference, KB, applier, reporter)
Handles cleanup and error recovery

config_parser.py (Legacy)

Backward compatibility layer for old function-based API
Parses device configs and extracts protocol info
Provides global helper functions (is_eigrp_router, get_baseline, etc.)
NOTE: Largely superseded by ConfigManager class


Data Files
history/configs/config_stable.txt

Stores stable baseline configurations for all devices
KEY LOGIC: Source of truth for expected network state
Contains full running configs with EIGRP, OSPF, interface settings
Used for validation, comparison, and restoration

history/runs/run.txt
stores run information and changes

history/knowledge
empty right now